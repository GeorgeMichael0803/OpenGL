#version 330 // OpenGL version 3.3 (minimum requirement)

in vec3 retColor;        // MUST use the same name as the out variable used by the vertex shader
in vec2 retTexCoord;     // out variable from the vertex shader

out vec4 FragColor;

uniform sampler2D sampler1;
uniform sampler2D sampler2;

uniform float YValue;     
uniform float UValue;      
uniform float VValue;      
uniform bool InvertColors; 


// Multiplying matrix values gives errors , try to find out why 
// to convert RGB to YUV by directly applying matrix multiplication formula
vec3 RGBtoYUV(vec3 rgb) {
    float Y = 0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b;
    float U = -0.14713 * rgb.r + -0.28886 * rgb.g + 0.436 * rgb.b;
    float V = 0.615 * rgb.r + -0.51499 * rgb.g + -0.10001 * rgb.b;

    return vec3(Y, U, V);
}

// to convert YUV back to RGB
vec3 YUVtoRGB(vec3 yuv) {
    float R = yuv.r + 1.13983 * yuv.b;
    float G = yuv.r - 0.39465 * yuv.g - 0.58060 * yuv.b;
    float B = yuv.r + 2.03211 * yuv.g;

    return vec3(R, G, B);
}

vec4 texColor;  
vec3 yuv;       
vec3 rgb;     

void main()
{   
    texColor = mix(texture(sampler1, retTexCoord), texture(sampler2, retTexCoord), 0.5) * vec4(retColor, 1.0f);

    yuv = RGBtoYUV(texColor.rgb);

    yuv.r *= YValue; 
    yuv.g *= UValue;  
    yuv.b *= VValue;  

    rgb = YUVtoRGB(yuv);
   
    if (InvertColors) {
        rgb = vec3(1.0) - rgb;  // Invert RGB values
    }


    FragColor = vec4(rgb, 1.0);
}
